{
    "exports": {
        "default": {
            "Emitter": {
                "changedStores": {
                    "toJSON": "function(){return Array.from(this)}",
                    "has": "function has() { [native code] }",
                    "add": "function add() { [native code] }",
                    "delete": "function delete() { [native code] }",
                    "clear": "function clear() { [native code] }",
                    "entries": "function entries() { [native code] }",
                    "forEach": "function forEach() { [native code] }",
                    "size": 0,
                    "values": "function values() { [native code] }",
                    "keys": "function values() { [native code] }",
                    "union": "function union() { [native code] }",
                    "intersection": "function intersection() { [native code] }",
                    "difference": "function difference() { [native code] }",
                    "symmetricDifference": "function symmetricDifference() { [native code] }",
                    "isSubsetOf": "function isSubsetOf() { [native code] }",
                    "isSupersetOf": "function isSupersetOf() { [native code] }",
                    "isDisjointFrom": "function isDisjointFrom() { [native code] }"
                },
                "reactChangedStores": {
                    "toJSON": "function(){return Array.from(this)}",
                    "has": "function has() { [native code] }",
                    "add": "function add() { [native code] }",
                    "delete": "function delete() { [native code] }",
                    "clear": "function clear() { [native code] }",
                    "entries": "function entries() { [native code] }",
                    "forEach": "function forEach() { [native code] }",
                    "size": 0,
                    "values": "function values() { [native code] }",
                    "keys": "function values() { [native code] }",
                    "union": "function union() { [native code] }",
                    "intersection": "function intersection() { [native code] }",
                    "difference": "function difference() { [native code] }",
                    "symmetricDifference": "function symmetricDifference() { [native code] }",
                    "isSubsetOf": "function isSubsetOf() { [native code] }",
                    "isSupersetOf": "function isSupersetOf() { [native code] }",
                    "isDisjointFrom": "function isDisjointFrom() { [native code] }"
                },
                "changeSentinel": 22,
                "isBatchEmitting": false,
                "isDispatching": false,
                "isPaused": false,
                "pauseTimer": null,
                "destroy": "destroy(){this.changedStores.clear(),this.reactChangedStores.clear(),r=e=>e()}",
                "injectBatchEmitChanges": "injectBatchEmitChanges(e){r=e}",
                "pause": "pause(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.isPaused=!0,null!==this.pauseTimer&&clearTimeout(this.pauseTimer),null!==e&&(this.pauseTimer=setTimeout(()=>{this.pauseTimer=null,this.resume()},e))}",
                "resume": "resume(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];clearTimeout(this.pauseTimer),this.pauseTimer=null,this.isPaused&&(this.isPaused=!1,e&&this.changedStores.size>0&&setImmediate(()=>this.emit()))}",
                "batched": "batched(e){if(this.isPaused)return e();try{return this.isPaused=!0,e()}finally{this.resume(!1),this.emit()}}",
                "emit": "emit(){!this.isBatchEmitting&&!this.isPaused&&r(()=>{try{this.isBatchEmitting=!0,this.changeSentinel++;let e=0;for(;this.changedStores.size>0;){if(++e>100)throw n.error(\"LastFewActions\",o.serialize()),Error(\"change emit loop detected, aborting\");this.emitNonReactOnce()}for(;this.reactChangedStores.size>0;){if(++e>100)throw n.error(\"LastFewActions\",o.serialize()),Error(\"react change emit loop detected, aborting\");this.emitReactOnce()}}finally{this.isBatchEmitting=!1}})}",
                "getChangeSentinel": "getChangeSentinel(){return this.changeSentinel}",
                "getIsPaused": "getIsPaused(){return this.isPaused}",
                "markChanged": "markChanged(e){e._changeCallbacks.hasAny()&&this.changedStores.add(e),e._reactChangeCallbacks.hasAny()&&this.reactChangedStores.add(e),!this.isBatchEmitting&&!this.isDispatching&&!this.isPaused&&this.emit()}",
                "emitNonReactOnce": "emitNonReactOnce(){let e=Date.now(),_=this.changedStores;this.changedStores=new Set,_.forEach(e=>{e._changeCallbacks.invokeAll(),this.changedStores.delete(e)});let E=Date.now();E-e>100&&n.verbose(\"Slow batch emitChanges took \".concat(E-e,\"ms recentActions:\"),o.serialize())}",
                "emitReactOnce": "emitReactOnce(){let e=Date.now(),_=this.reactChangedStores;this.reactChangedStores=new Set,_.forEach(e=>{e._reactChangeCallbacks.invokeAll(),this.reactChangedStores.delete(e)});let E=Date.now();E-e>100&&n.verbose(\"Slow batch emitReactChanges took \".concat(E-e,\"ms recentActions:\"),o.serialize())}"
            },
            "Store": "class{static initialize(){S=!0,T.forEach(e=>e.initializeIfNeeded()),null!=t&&t()}static destroy(){T.length=0,s.default.destroy()}static getAll(){return T}registerActionHandlers(e,_){this._dispatcher.register(this.getName(),e,e=>{(this._changeCallbacks.hasAny()||this._reactChangeCallbacks.hasAny())&&(s.default.markChanged(this),s.default.getIsPaused()&&null!=this._mustEmitChanges&&this._mustEmitChanges(e)&&s.default.resume(!1))},_,this._dispatchToken)}getName(){var e;return null!==(e=this.constructor.displayName)&&void 0!==e?e:this.constructor.name}initializeIfNeeded(){if(!this._isInitialized){let e=Date.now();this.initialize(),this._isInitialized=!0;let _=Date.now()-e;_>5&&a.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",_)}}initialize(){}syncWith(e,_,E){var t,o;let n;this.waitFor(...e);let r=0,i=()=>{r!==s.default.getChangeSentinel()&&(r=s.default.getChangeSentinel(),!1!==_()&&this.emitChange())};t=null!=E?E:0,o=i,n=null,i=0===t?function(){clearImmediate(n),n=setImmediate(o)}:function(){null==n&&(n=setTimeout(()=>{try{o()}finally{n=null}},t))},e.forEach(e=>e.addChangeListener(i))}waitFor(){for(var e=arguments.length,_=Array(e),E=0;E<e;E++)_[E]=arguments[E];let t=_.map((e,_)=>(i(null!=e,\"Store.waitFor(...) called with null Store at index \".concat(_,\" for store \").concat(this.getName())),null!=e._dispatcher)?(i(e._dispatcher===this._dispatcher,\"Stores belong to two separate dispatchers.\"),e.getDispatchToken()):null);this._dispatcher.addDependencies(this.getDispatchToken(),t.filter(e=>null!=e))}emitChange(){s.default.markChanged(this)}getDispatchToken(){return this._dispatchToken}mustEmitChanges(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>!0;this._mustEmitChanges=e}constructor(e,_,E){this._changeCallbacks=new I.default,this._reactChangeCallbacks=new I.default,this._isInitialized=!1,this.addChangeListener=this._changeCallbacks.add,this.addConditionalChangeListener=this._changeCallbacks.addConditional,this.removeChangeListener=this._changeCallbacks.remove,this.addReactChangeListener=this._reactChangeCallbacks.add,this.removeReactChangeListener=this._reactChangeCallbacks.remove,this._dispatcher=e,this._dispatchToken=this._dispatcher.createToken(),this.registerActionHandlers(null!=_?_:{},E),T.push(this),S&&this.initializeIfNeeded()}}",
            "PersistedStore": "class e extends I.default{getClass(){return this.constructor}static clearAll(_){return T=_,null==e._clearAllPromise&&(e._clearAllPromise=new Promise(E=>{requestIdleCallback(()=>{e.clearPersistQueue(_),e.allPersistKeys.forEach(E=>{e.shouldClear(_,E)&&a.default.remove(E)}),I.default.getAll().forEach(E=>{E instanceof e&&e.shouldClear(_,E.getClass().persistKey)&&(E._isInitialized=!1,E.initializeIfNeeded())}),e._clearAllPromise=null,E()},{timeout:500})})),e._clearAllPromise}static shouldClear(_,E){var t;return(null===(t=_.omit)||void 0===t?!void 0:!t.includes(E))&&(\"all\"===_.type||\"user-data-only\"===_.type&&!e.userAgnosticPersistKeys.has(E))}static clearPersistQueue(_){e._writeResolvers.forEach((E,t)=>{let[o,n]=E;e.shouldClear(_,t)&&(e._writePromises.delete(t),e._writeResolvers.delete(t),cancelIdleCallback(n),o(!1))}),e._writePromises.clear(),e._writeResolvers.clear()}static getAllStates(){return Promise.all(Array.from(e._writePromises.values())).then(()=>{let _={};return e.allPersistKeys.forEach(e=>{var E;_[e]=(null!==(E=a.default.get(e))&&void 0!==E?E:s)._state}),_})}static initializeAll(_){I.default.getAll().forEach(E=>{if(E instanceof e){let e=E.getClass().persistKey;_.hasOwnProperty(e)&&E.initializeFromState(_[e])}})}initializeFromState(_){this.initialize(_)&&this.asyncPersist(),this._isInitialized?this.emitChange():(e.allPersistKeys.add(this.getClass().persistKey),this._isInitialized=!0)}static destroy(){T=null,I.default.destroy(),e.clearPersistQueue({type:\"all\"}),e.allPersistKeys.clear(),e.userAgnosticPersistKeys.clear()}initializeIfNeeded(){if(!this._isInitialized){let _=Date.now();e.allPersistKeys.add(this.getClass().persistKey);let{state:E,requiresPersist:t}=e.migrateAndReadStoreState(this.getClass().persistKey,this.getClass().migrations);this.initialize(E)&&this.asyncPersist(),t&&this.asyncPersist(),this._isInitialized=!0;let o=Date.now()-_;o>5&&i.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",o)}}static migrateAndReadStoreState(_,E){if(null!=T&&e.shouldClear(T,_))return a.default.remove(_),{state:void 0,requiresPersist:!1};let t=null!=e._clearAllPromise?null:a.default.get(_),{_state:o,_version:n,...r}=null!=t?t:s,i=null==E?0:E.length;if(0!==i&&n!==i&&null!=E){let e=null!=n?n:0,_=o;for(null==n&&(_=r);e<i;){let t=E[e];_=t(_),e++}return{state:_,requiresPersist:!0}}if(Object.values(r).length>0)return{state:r,requiresPersist:!0};return{state:o,requiresPersist:!1}}asyncPersist(){let{persistKey:_,disableWrite:E,throttleDelay:t}=this.getClass();if(e.disableWrites||E)return Promise.resolve(!1);let o=e._writePromises.get(_);return null!=o?o:(o=new Promise(E=>{let o=t>0?()=>this.throttledCallback(E):()=>this.callback(E);e._writeResolvers.set(_,[E,requestIdleCallback(o,{timeout:500})])}),e._writePromises.set(_,o),o)}persist(){let{persistKey:e}=this.getClass(),_=this.getState(),E=this._version;a.default.set(e,{_state:_,_version:E})}clear(){let{persistKey:e}=this.getClass();a.default.remove(e)}constructor(_,E){if(super(_,E),this._version=null==this.getClass().migrations?0:this.getClass().migrations.length,this.callback=_=>{let{persistKey:E}=this.getClass();this.persist(),e._writePromises.delete(E),e._writeResolvers.delete(E),_()},this.throttledCallback=r.throttle(e=>this.callback(e),this.getClass().throttleDelay,{leading:!1}),\"string\"!=typeof this.getClass().persistKey)throw Error(\"\".concat(this.getClass().name,\" initialized without a `persistKey`. Add one so we know where to save your stuff!\"));if(\"function\"!=typeof this.initialize)throw Error(\"\".concat(this.getClass().name,\" initialized without an `initialize` method. Add one that accepts the initial cached state.\"));if(\"function\"!=typeof this.getState)throw Error(\"\".concat(this.getClass().name,\" initialized without a `getState` method. Add one that returns the full state of the store for persistance to work.\"));this.addChangeListener(()=>this.asyncPersist())}}",
            "DeviceSettingsStore": "class N extends S{}",
            "OfflineCacheStore": "class O extends S{}",
            "connectStores": "function(e,_,E){return null!=E&&E.forwardRef?function(e,_){return E=>{let i=\"FluxContainer(\".concat(a(E),\")\");class s extends o.Component{componentDidMount(){this.listener.attach(i)}componentWillUnmount(){this.listener.detach(),this.memoizedGetStateFromStores.clear()}render(){let{forwardedConnectStoresRef:e,childProps:_}=this.props,o=this.memoizedGetStateFromStores(_);return(0,t.jsx)(E,{ref:e,..._,...o})}constructor(...E){super(...E),this.memoizedGetStateFromStores=I(_),this.listener=new r.default(e,()=>{let e=this.memoizedGetStateFromStores.getCachedResult(this.props.childProps);if(!(null!=e&&(this.memoizedGetStateFromStores.clear(),(0,n.default)(this.memoizedGetStateFromStores(this.props.childProps),e))))this.forceUpdate()})}}s.displayName=i;let T=o.forwardRef((e,_)=>(0,t.jsx)(s,{childProps:e,forwardedConnectStoresRef:_}));return T.displayName=\"ForwardRef(\".concat(i,\")\"),T}}(e,_):function(e,_){return E=>{let i=\"FluxContainer(\".concat(a(E),\")\");class s extends o.Component{componentDidMount(){this.listener.attach(i)}componentWillUnmount(){this.listener.detach(),this.memoizedGetStateFromStores.clear()}render(){let e=this.memoizedGetStateFromStores(this.props);return(0,t.jsx)(E,{...this.props,...e})}constructor(...E){super(...E),this.memoizedGetStateFromStores=I(_),this.listener=new r.default(e,()=>{let e=this.memoizedGetStateFromStores.getCachedResult(this.props);if(!(null!=e&&(this.memoizedGetStateFromStores.clear(),(0,n.default)(this.memoizedGetStateFromStores(this.props),e))))this.forceUpdate()})}}return s.displayName=i,s}}(e,_)}",
            "initialize": "initialize(){n.default.initialize()}",
            "initialized": {
                "then": "function then() { [native code] }",
                "catch": "function catch() { [native code] }",
                "finally": "function finally() { [native code] }"
            },
            "destroy": "destroy(){o.default.destroy()}"
        }
    }
}