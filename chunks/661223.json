{
    "exports": {
        "BatchedStoreListener": "class r{constructor(e,t){this.handleStoreChange=()=>{let e=i.default.getChangeSentinel();this.storeVersionHandled!==e&&(this.changeCallback(),this.storeVersionHandled=e)},this.stores=e,this.changeCallback=t}attach(e){let{stores:t}=this;t.forEach((t,n)=>{if(null==t)throw Error(`${e} tried to load a non-existent store. Either it isn't defined or there is a circular dependency. Loaded ${n} stores before error.`);t.addReactChangeListener(this.handleStoreChange)})}detach(){let{stores:e}=this;e.forEach(e=>e.removeReactChangeListener(this.handleStoreChange))}}",
        "Dispatcher": "class c{constructor(e=0,t,n){this._interceptors=[],this._subscriptions={},this._waitQueue=[],this._processingWaitQueue=!1,this._currentDispatchActionType=null,this._actionHandlers=new d,this._sentryUtils=void 0,this.functionCache={},this._defaultBand=e,this._sentryUtils=n,null!=t?this.actionLogger=t:this.actionLogger=new u.ActionLogger,this.actionLogger.on(\"trace\",(e,t,n)=>{a.default.isTracing&&n>=10&&a.default.mark(\"\\uD83E\\uDDA5\",t,n)})}isDispatching(){return null!=this._currentDispatchActionType}dispatch(e){return new Promise((t,n)=>{this._waitQueue.push(()=>{try{null==this.functionCache[e.type]&&(this.functionCache[e.type]=e=>this._dispatchWithDevtools(e),S(this.functionCache[e.type],\"dispatch_\"+e.type)),this.functionCache[e.type](e),t()}catch(e){n(e)}}),this.flushWaitQueue()})}flushWaitQueue(){if(!this._processingWaitQueue)try{this._processingWaitQueue=!0,E.default.isDispatching=!0;let e=0;for(;this._waitQueue.length>0;){if(++e>100){let e=l.serialize();throw T.error(\"LastFewActions\",e),this._sentryUtils?.addBreadcrumb({message:\"Dispatcher: Dispatch loop detected\",data:{lastFewActions:e}}),Error(\"Dispatch loop detected, aborting\")}for(;this._waitQueue.length>0;)this._waitQueue.shift()();E.default.emit()}}finally{this._processingWaitQueue=!1,E.default.isDispatching=!1}}_dispatchWithDevtools(e){this._dispatchWithLogging(e)}_dispatchWithLogging(e){o()(null==this._currentDispatchActionType,`Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch. Action: ${e.type} Already dispatching: ${this._currentDispatchActionType}`),o()(e.type,\"Dispatch.dispatch(...) called without an action type\"),I.has(e.type)&&T.log(`Dispatching ${e.type}`),(0,_.mark)(e.type),l.add(e.type);let t=this.actionLogger.log(e,t=>{try{this._currentDispatchActionType=e.type,this._dispatch(e,t)}finally{this._currentDispatchActionType=null}});t.totalTime>100&&T.verbose(`Slow dispatch on ${e.type}: ${t.totalTime}ms`);try{(0,_.measure)(`DISPATCH[${e.type}]`,e.type)}catch(e){}}_dispatch(e,t){for(let t of this._interceptors)if(t(e))return!1;let n=this._actionHandlers.getOrderedActionHandlers(e);for(let i=0,r=n.length;i<r;i++){let{name:r,actionHandler:o,storeDidChange:a}=n[i];!1!==t(r,()=>o(e))&&a(e)}let i=this._subscriptions[e.type];null!=i&&t(\"__subscriptions\",()=>{i.forEach(t=>t(e))})}addInterceptor(e){this._interceptors.push(e)}wait(e){this._waitQueue.push(e),this.flushWaitQueue()}subscribe(e,t){let n=this._subscriptions[e];null==n&&(this._subscriptions[e]=n=new Set),n.add(t)}unsubscribe(e,t){let n=this._subscriptions[e];null!=n&&(n.delete(t),0===n.size&&delete this._subscriptions[e])}register(e,t,n,i,r){return this._actionHandlers.register(e,t,n,i??this._defaultBand,r)}createToken(){return this._actionHandlers.createToken()}addDependencies(e,t){this._actionHandlers.addDependencies(e,t)}}",
        "Store": "class I{static initialize(){l=!0,E.forEach(e=>e.initializeIfNeeded()),null!=i&&i()}static #e=this.initialized=u;static destroy(){E.length=0,_.default.destroy()}static getAll(){return E}constructor(e,t,n){this._changeCallbacks=new s.default,this._reactChangeCallbacks=new s.default,this._isInitialized=!1,this.addChangeListener=this._changeCallbacks.add,this.addConditionalChangeListener=this._changeCallbacks.addConditional,this.removeChangeListener=this._changeCallbacks.remove,this.addReactChangeListener=this._reactChangeCallbacks.add,this.removeReactChangeListener=this._reactChangeCallbacks.remove,this._dispatcher=e,this._dispatchToken=this._dispatcher.createToken(),this.registerActionHandlers(t??{},n),E.push(this),l&&this.initializeIfNeeded()}registerActionHandlers(e,t){this._dispatcher.register(this.getName(),e,e=>{(this._changeCallbacks.hasAny()||this._reactChangeCallbacks.hasAny())&&(_.default.markChanged(this),_.default.getIsPaused()&&null!=this._mustEmitChanges&&this._mustEmitChanges(e)&&_.default.resume(!1))},t,this._dispatchToken)}getName(){return this.constructor.displayName??this.constructor.name}initializeIfNeeded(){if(!this._isInitialized){let e=Date.now();this.initialize(),this._isInitialized=!0;let t=Date.now()-e;t>5&&a.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",t)}}initialize(){}syncWith(e,t,n){var i,r;let o;this.waitFor(...e);let a=0,s=()=>{a!==_.default.getChangeSentinel()&&(a=_.default.getChangeSentinel(),!1!==t()&&this.emitChange())};i=n??0,r=s,o=null,s=0===i?function(){clearImmediate(o),o=setImmediate(r)}:function(){null==o&&(o=setTimeout(()=>{try{r()}finally{o=null}},i))},e.forEach(e=>e.addChangeListener(s))}waitFor(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let i=t.map((e,t)=>(o()(null!=e,`Store.waitFor(...) called with null Store at index ${t} for store ${this.getName()}`),null!=e._dispatcher)?(o()(e._dispatcher===this._dispatcher,\"Stores belong to two separate dispatchers.\"),e.getDispatchToken()):null);this._dispatcher.addDependencies(this.getDispatchToken(),i.filter(e=>null!=e))}emitChange(){_.default.markChanged(this)}getDispatchToken(){return this._dispatchToken}mustEmitChanges(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>!0;this._mustEmitChanges=e}}",
        "default": {
            "Emitter": {
                "changedStores": {
                    "toJSON": "function(){return Array.from(this)}",
                    "has": "function has() { [native code] }",
                    "add": "function add() { [native code] }",
                    "delete": "function delete() { [native code] }",
                    "clear": "function clear() { [native code] }",
                    "entries": "function entries() { [native code] }",
                    "forEach": "function forEach() { [native code] }",
                    "size": 0,
                    "values": "function values() { [native code] }",
                    "keys": "function values() { [native code] }",
                    "union": "function union() { [native code] }",
                    "intersection": "function intersection() { [native code] }",
                    "difference": "function difference() { [native code] }",
                    "symmetricDifference": "function symmetricDifference() { [native code] }",
                    "isSubsetOf": "function isSubsetOf() { [native code] }",
                    "isSupersetOf": "function isSupersetOf() { [native code] }",
                    "isDisjointFrom": "function isDisjointFrom() { [native code] }"
                },
                "reactChangedStores": {
                    "toJSON": "function(){return Array.from(this)}",
                    "has": "function has() { [native code] }",
                    "add": "function add() { [native code] }",
                    "delete": "function delete() { [native code] }",
                    "clear": "function clear() { [native code] }",
                    "entries": "function entries() { [native code] }",
                    "forEach": "function forEach() { [native code] }",
                    "size": 0,
                    "values": "function values() { [native code] }",
                    "keys": "function values() { [native code] }",
                    "union": "function union() { [native code] }",
                    "intersection": "function intersection() { [native code] }",
                    "difference": "function difference() { [native code] }",
                    "symmetricDifference": "function symmetricDifference() { [native code] }",
                    "isSubsetOf": "function isSubsetOf() { [native code] }",
                    "isSupersetOf": "function isSupersetOf() { [native code] }",
                    "isDisjointFrom": "function isDisjointFrom() { [native code] }"
                },
                "changeSentinel": 21,
                "isBatchEmitting": false,
                "isDispatching": false,
                "isPaused": false,
                "pauseTimer": null,
                "destroy": "destroy(){this.changedStores.clear(),this.reactChangedStores.clear(),a=e=>e()}",
                "injectBatchEmitChanges": "injectBatchEmitChanges(e){a=e}",
                "pause": "pause(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.isPaused=!0,null!==this.pauseTimer&&clearTimeout(this.pauseTimer),null!==e&&(this.pauseTimer=setTimeout(()=>{this.pauseTimer=null,this.resume()},e))}",
                "resume": "resume(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];clearTimeout(this.pauseTimer),this.pauseTimer=null,this.isPaused&&(this.isPaused=!1,e&&this.changedStores.size>0&&setImmediate(()=>this.emit()))}",
                "batched": "batched(e){if(this.isPaused)return e();try{return this.isPaused=!0,e()}finally{this.resume(!1),this.emit()}}",
                "emit": "emit(){!this.isBatchEmitting&&!this.isPaused&&a(()=>{try{this.isBatchEmitting=!0,this.changeSentinel++;let e=0;for(;this.changedStores.size>0;){if(++e>100)throw o.error(\"LastFewActions\",r.serialize()),Error(\"change emit loop detected, aborting\");this.emitNonReactOnce()}for(;this.reactChangedStores.size>0;){if(++e>100)throw o.error(\"LastFewActions\",r.serialize()),Error(\"react change emit loop detected, aborting\");this.emitReactOnce()}}finally{this.isBatchEmitting=!1}})}",
                "getChangeSentinel": "getChangeSentinel(){return this.changeSentinel}",
                "getIsPaused": "getIsPaused(){return this.isPaused}",
                "markChanged": "markChanged(e){e._changeCallbacks.hasAny()&&this.changedStores.add(e),e._reactChangeCallbacks.hasAny()&&this.reactChangedStores.add(e),!this.isBatchEmitting&&!this.isDispatching&&!this.isPaused&&this.emit()}",
                "emitNonReactOnce": "emitNonReactOnce(){let e=Date.now(),t=this.changedStores;this.changedStores=new Set,t.forEach(e=>{e._changeCallbacks.invokeAll(),this.changedStores.delete(e)});let n=Date.now();n-e>100&&o.verbose(`Slow batch emitChanges took ${n-e}ms recentActions:`,r.serialize())}",
                "emitReactOnce": "emitReactOnce(){let e=Date.now(),t=this.reactChangedStores;this.reactChangedStores=new Set,t.forEach(e=>{e._reactChangeCallbacks.invokeAll(),this.reactChangedStores.delete(e)});let n=Date.now();n-e>100&&o.verbose(`Slow batch emitReactChanges took ${n-e}ms recentActions:`,r.serialize())}"
            },
            "Store": "class I{static initialize(){l=!0,E.forEach(e=>e.initializeIfNeeded()),null!=i&&i()}static #e=this.initialized=u;static destroy(){E.length=0,_.default.destroy()}static getAll(){return E}constructor(e,t,n){this._changeCallbacks=new s.default,this._reactChangeCallbacks=new s.default,this._isInitialized=!1,this.addChangeListener=this._changeCallbacks.add,this.addConditionalChangeListener=this._changeCallbacks.addConditional,this.removeChangeListener=this._changeCallbacks.remove,this.addReactChangeListener=this._reactChangeCallbacks.add,this.removeReactChangeListener=this._reactChangeCallbacks.remove,this._dispatcher=e,this._dispatchToken=this._dispatcher.createToken(),this.registerActionHandlers(t??{},n),E.push(this),l&&this.initializeIfNeeded()}registerActionHandlers(e,t){this._dispatcher.register(this.getName(),e,e=>{(this._changeCallbacks.hasAny()||this._reactChangeCallbacks.hasAny())&&(_.default.markChanged(this),_.default.getIsPaused()&&null!=this._mustEmitChanges&&this._mustEmitChanges(e)&&_.default.resume(!1))},t,this._dispatchToken)}getName(){return this.constructor.displayName??this.constructor.name}initializeIfNeeded(){if(!this._isInitialized){let e=Date.now();this.initialize(),this._isInitialized=!0;let t=Date.now()-e;t>5&&a.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",t)}}initialize(){}syncWith(e,t,n){var i,r;let o;this.waitFor(...e);let a=0,s=()=>{a!==_.default.getChangeSentinel()&&(a=_.default.getChangeSentinel(),!1!==t()&&this.emitChange())};i=n??0,r=s,o=null,s=0===i?function(){clearImmediate(o),o=setImmediate(r)}:function(){null==o&&(o=setTimeout(()=>{try{r()}finally{o=null}},i))},e.forEach(e=>e.addChangeListener(s))}waitFor(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];let i=t.map((e,t)=>(o()(null!=e,`Store.waitFor(...) called with null Store at index ${t} for store ${this.getName()}`),null!=e._dispatcher)?(o()(e._dispatcher===this._dispatcher,\"Stores belong to two separate dispatchers.\"),e.getDispatchToken()):null);this._dispatcher.addDependencies(this.getDispatchToken(),i.filter(e=>null!=e))}emitChange(){_.default.markChanged(this)}getDispatchToken(){return this._dispatchToken}mustEmitChanges(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>!0;this._mustEmitChanges=e}}",
            "PersistedStore": "class l extends s.default{static #e=this.allPersistKeys=new Set;static #t=this.userAgnosticPersistKeys=new Set;static #n=this._writePromises=new Map;static #i=this._writeResolvers=new Map;static #r=this.disableWrites=!1;static #o=this.disableWrite=!1;static #a=this.throttleDelay=0;getClass(){return this.constructor}static clearAll(e){return E=e,null==l._clearAllPromise&&(l._clearAllPromise=new Promise(t=>{requestIdleCallback(()=>{l.clearPersistQueue(e),l.allPersistKeys.forEach(t=>{l.shouldClear(e,t)&&a.default.remove(t)}),s.default.getAll().forEach(t=>{t instanceof l&&l.shouldClear(e,t.getClass().persistKey)&&(t._isInitialized=!1,t.initializeIfNeeded())}),l._clearAllPromise=null,t()},{timeout:500})})),l._clearAllPromise}static shouldClear(e,t){return!e.omit?.includes(t)&&(\"all\"===e.type||\"user-data-only\"===e.type&&!l.userAgnosticPersistKeys.has(t))}static clearPersistQueue(e){l._writeResolvers.forEach((t,n)=>{let[i,r]=t;l.shouldClear(e,n)&&(l._writePromises.delete(n),l._writeResolvers.delete(n),cancelIdleCallback(r),i(!1))}),l._writePromises.clear(),l._writeResolvers.clear()}static getAllStates(){return Promise.all(Array.from(l._writePromises.values())).then(()=>{let e={};return l.allPersistKeys.forEach(t=>{e[t]=(a.default.get(t)??_)._state}),e})}static initializeAll(e){s.default.getAll().forEach(t=>{if(t instanceof l){let n=t.getClass().persistKey;e.hasOwnProperty(n)&&t.initializeFromState(e[n])}})}initializeFromState(e){this.initialize(e)&&this.asyncPersist(),this._isInitialized?this.emitChange():(l.allPersistKeys.add(this.getClass().persistKey),this._isInitialized=!0)}static destroy(){E=null,s.default.destroy(),l.clearPersistQueue({type:\"all\"}),l.allPersistKeys.clear(),l.userAgnosticPersistKeys.clear()}constructor(e,t){if(super(e,t),this._version=null==this.getClass().migrations?0:this.getClass().migrations.length,this.callback=e=>{let{persistKey:t}=this.getClass();this.persist(),l._writePromises.delete(t),l._writeResolvers.delete(t),e()},this.throttledCallback=r().throttle(e=>this.callback(e),this.getClass().throttleDelay,{leading:!1}),\"string\"!=typeof this.getClass().persistKey)throw Error(`${this.getClass().name} initialized without a \\`persistKey\\`. Add one so we know where to save your stuff!`);if(\"function\"!=typeof this.initialize)throw Error(`${this.getClass().name} initialized without an \\`initialize\\` method. Add one that accepts the initial cached state.`);if(\"function\"!=typeof this.getState)throw Error(`${this.getClass().name} initialized without a \\`getState\\` method. Add one that returns the full state of the store for persistance to work.`);this.addChangeListener(()=>this.asyncPersist())}initializeIfNeeded(){if(!this._isInitialized){let e=Date.now();l.allPersistKeys.add(this.getClass().persistKey);let{state:t,requiresPersist:n}=l.migrateAndReadStoreState(this.getClass().persistKey,this.getClass().migrations);this.initialize(t)&&this.asyncPersist(),n&&this.asyncPersist(),this._isInitialized=!0;let i=Date.now()-e;i>5&&o.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",i)}}static migrateAndReadStoreState(e,t){if(null!=E&&l.shouldClear(E,e))return a.default.remove(e),{state:void 0,requiresPersist:!1};let{_state:n,_version:i,...r}=(null!=l._clearAllPromise?null:a.default.get(e))??_,o=null==t?0:t.length;if(0!==o&&i!==o&&null!=t){let e=i??0,a=n;for(null==i&&(a=r);e<o;)a=(0,t[e])(a),e++;return{state:a,requiresPersist:!0}}if(Object.values(r).length>0)return{state:r,requiresPersist:!0};return{state:n,requiresPersist:!1}}asyncPersist(){let{persistKey:e,disableWrite:t,throttleDelay:n}=this.getClass();if(l.disableWrites||t)return Promise.resolve(!1);let i=l._writePromises.get(e);return null!=i?i:(i=new Promise(t=>{let i=n>0?()=>this.throttledCallback(t):()=>this.callback(t);l._writeResolvers.set(e,[t,requestIdleCallback(i,{timeout:500})])}),l._writePromises.set(e,i),i)}persist(){let{persistKey:e}=this.getClass(),t=this.getState(),n=this._version;a.default.set(e,{_state:t,_version:n})}clear(){let{persistKey:e}=this.getClass();a.default.remove(e)}}",
            "DeviceSettingsStore": "class I extends u{}",
            "OfflineCacheStore": "class T extends u{}",
            "connectStores": "function(e,t,n){return null!=n&&n.forwardRef?function(e,t){return n=>{let s=`FluxContainer(${_(n)})`;class l extends r.Component{static #e=this.displayName=s;componentDidMount(){this.listener.attach(s)}componentWillUnmount(){this.listener.detach(),this.memoizedGetStateFromStores.clear()}render(){let{forwardedConnectStoresRef:e,childProps:t}=this.props,r=this.memoizedGetStateFromStores(t);return(0,i.jsx)(n,{ref:e,...t,...r})}constructor(...n){super(...n),this.memoizedGetStateFromStores=E(t),this.listener=new a.default(e,()=>{let e=this.memoizedGetStateFromStores.getCachedResult(this.props.childProps);if(!(null!=e&&(this.memoizedGetStateFromStores.clear(),(0,o.default)(this.memoizedGetStateFromStores(this.props.childProps),e))))this.forceUpdate()})}}let u=r.forwardRef((e,t)=>(0,i.jsx)(l,{childProps:e,forwardedConnectStoresRef:t}));return u.displayName=`ForwardRef(${s})`,u}}(e,t):function(e,t){return n=>{let s=`FluxContainer(${_(n)})`;class l extends r.Component{static #e=this.displayName=s;componentDidMount(){this.listener.attach(s)}componentWillUnmount(){this.listener.detach(),this.memoizedGetStateFromStores.clear()}render(){let e=this.memoizedGetStateFromStores(this.props);return(0,i.jsx)(n,{...this.props,...e})}constructor(...n){super(...n),this.memoizedGetStateFromStores=E(t),this.listener=new a.default(e,()=>{let e=this.memoizedGetStateFromStores.getCachedResult(this.props);if(!(null!=e&&(this.memoizedGetStateFromStores.clear(),(0,o.default)(this.memoizedGetStateFromStores(this.props),e))))this.forceUpdate()})}}return l}}(e,t)}",
            "initialize": "initialize(){o.default.initialize()}",
            "initialized": {
                "then": "function then() { [native code] }",
                "catch": "function catch() { [native code] }",
                "finally": "function finally() { [native code] }"
            },
            "destroy": "destroy(){r.default.destroy()}"
        },
        "statesWillNeverBeEqual": "function s(e,t){return!1}",
        "useStateFromStores": "function _(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a,{current:_}=(0,i.useRef)({stores:e,areStatesEqual:s,getStateFromStores:t,prevDeps:void 0,state:void 0}),E=_.state;if(null==n||!(0,r.areArraysShallowEqual)(n,_.prevDeps)){let e=t();(null==E||!s(E,e))&&(E=e)}(0,i.useLayoutEffect)(()=>{_.getStateFromStores=t,_.prevDeps=n,_.state=E});let[,l]=(0,i.useState)(null);return(0,i.useLayoutEffect)(()=>{let t=()=>{let e=_.getStateFromStores();!s(_.state,e)&&(_.state=e,l({}))};t();let n=new o.default(e,t);return n.attach(\"useStateFromStores\"),()=>n.detach()},[]),E}",
        "useStateFromStoresArray": "function l(e,t,n){return _(e,t,n,r.areArraysShallowEqual)}",
        "useStateFromStoresObject": "function E(e,t,n){return _(e,t,n,r.default)}"
    }
}