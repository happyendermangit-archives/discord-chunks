{
    "exports": {
        "Store": "class{static initialize(){S=!0,T.forEach(e=>e.initializeIfNeeded()),null!=t&&t()}static destroy(){T.length=0,s.default.destroy()}static getAll(){return T}registerActionHandlers(e,_){this._dispatcher.register(this.getName(),e,e=>{(this._changeCallbacks.hasAny()||this._reactChangeCallbacks.hasAny())&&(s.default.markChanged(this),s.default.getIsPaused()&&null!=this._mustEmitChanges&&this._mustEmitChanges(e)&&s.default.resume(!1))},_,this._dispatchToken)}getName(){var e;return null!==(e=this.constructor.displayName)&&void 0!==e?e:this.constructor.name}initializeIfNeeded(){if(!this._isInitialized){let e=Date.now();this.initialize(),this._isInitialized=!0;let _=Date.now()-e;_>5&&a.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",_)}}initialize(){}syncWith(e,_,E){var t,o;let n;this.waitFor(...e);let r=0,i=()=>{r!==s.default.getChangeSentinel()&&(r=s.default.getChangeSentinel(),!1!==_()&&this.emitChange())};t=null!=E?E:0,o=i,n=null,i=0===t?function(){clearImmediate(n),n=setImmediate(o)}:function(){null==n&&(n=setTimeout(()=>{try{o()}finally{n=null}},t))},e.forEach(e=>e.addChangeListener(i))}waitFor(){for(var e=arguments.length,_=Array(e),E=0;E<e;E++)_[E]=arguments[E];let t=_.map((e,_)=>(i(null!=e,\"Store.waitFor(...) called with null Store at index \".concat(_,\" for store \").concat(this.getName())),null!=e._dispatcher)?(i(e._dispatcher===this._dispatcher,\"Stores belong to two separate dispatchers.\"),e.getDispatchToken()):null);this._dispatcher.addDependencies(this.getDispatchToken(),t.filter(e=>null!=e))}emitChange(){s.default.markChanged(this)}getDispatchToken(){return this._dispatchToken}mustEmitChanges(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>!0;this._mustEmitChanges=e}constructor(e,_,E){this._changeCallbacks=new I.default,this._reactChangeCallbacks=new I.default,this._isInitialized=!1,this.addChangeListener=this._changeCallbacks.add,this.addConditionalChangeListener=this._changeCallbacks.addConditional,this.removeChangeListener=this._changeCallbacks.remove,this.addReactChangeListener=this._reactChangeCallbacks.add,this.removeReactChangeListener=this._reactChangeCallbacks.remove,this._dispatcher=e,this._dispatchToken=this._dispatcher.createToken(),this.registerActionHandlers(null!=_?_:{},E),T.push(this),S&&this.initializeIfNeeded()}}",
        "Dispatcher": "class O{isDispatching(){return null!=this._currentDispatchActionType}dispatch(e){return new Promise((_,E)=>{this._waitQueue.push(()=>{try{null==this.functionCache[e.type]&&(this.functionCache[e.type]=e=>this._dispatchWithDevtools(e),R(this.functionCache[e.type],\"dispatch_\"+e.type)),this.functionCache[e.type](e),_()}catch(e){E(e)}}),this.flushWaitQueue()})}flushWaitQueue(){if(!this._processingWaitQueue)try{this._processingWaitQueue=!0,I.default.isDispatching=!0;let _=0;for(;this._waitQueue.length>0;){if(++_>100){var e;let _=s.serialize();throw N.error(\"LastFewActions\",_),null===(e=this._sentryUtils)||void 0===e||e.addBreadcrumb({message:\"Dispatcher: Dispatch loop detected\",data:{lastFewActions:_}}),Error(\"Dispatch loop detected, aborting\")}for(;this._waitQueue.length>0;){let e=this._waitQueue.shift();e()}I.default.emit()}}finally{this._processingWaitQueue=!1,I.default.isDispatching=!1}}_dispatchWithDevtools(e){this._dispatchWithLogging(e)}_dispatchWithLogging(e){n(null==this._currentDispatchActionType,\"Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch. Action: \".concat(e.type,\" Already dispatching: \").concat(this._currentDispatchActionType)),n(e.type,\"Dispatch.dispatch(...) called without an action type\"),S.has(e.type)&&N.log(\"Dispatching \".concat(e.type)),(0,a.mark)(e.type),s.add(e.type);let _=this.actionLogger.log(e,_=>{try{this._currentDispatchActionType=e.type,this._dispatch(e,_)}finally{this._currentDispatchActionType=null}});_.totalTime>100&&N.verbose(\"Slow dispatch on \".concat(e.type,\": \").concat(_.totalTime,\"ms\"));try{(0,a.measure)(\"DISPATCH[\".concat(e.type,\"]\"),e.type)}catch(e){}}_dispatch(e,_){for(let _ of this._interceptors)if(_(e))return!1;let E=this._actionHandlers.getOrderedActionHandlers(e);for(let t=0,o=E.length;t<o;t++){let{name:o,actionHandler:n,storeDidChange:r}=E[t];!1!==_(o,()=>n(e))&&r(e)}let t=this._subscriptions[e.type];null!=t&&_(\"__subscriptions\",()=>{t.forEach(_=>_(e))})}addInterceptor(e){this._interceptors.push(e)}wait(e){this._waitQueue.push(e),this.flushWaitQueue()}subscribe(e,_){let E=this._subscriptions[e];null==E&&(this._subscriptions[e]=E=new Set),E.add(_)}unsubscribe(e,_){let E=this._subscriptions[e];null!=E&&(E.delete(_),0===E.size&&delete this._subscriptions[e])}register(e,_,E,t,o){return this._actionHandlers.register(e,_,E,null!=t?t:this._defaultBand,o)}createToken(){return this._actionHandlers.createToken()}addDependencies(e,_){this._actionHandlers.addDependencies(e,_)}constructor(e=0,_,E){this._interceptors=[],this._subscriptions={},this._waitQueue=[],this._processingWaitQueue=!1,this._currentDispatchActionType=null,this._actionHandlers=new A,this._sentryUtils=void 0,this.functionCache={},this._defaultBand=e,this._sentryUtils=E,null!=_?this.actionLogger=_:this.actionLogger=new T.ActionLogger,this.actionLogger.on(\"trace\",(e,_,E)=>{r.default.isTracing&&E>=10&&r.default.mark(\"\\uD83E\\uDDA5\",_,E)})}}",
        "BatchedStoreListener": "class{attach(e){let{stores:_}=this;_.forEach((_,E)=>{if(null==_)throw Error(\"\".concat(e,\" tried to load a non-existent store. Either it isn't defined or there is a circular dependency. Loaded \").concat(E,\" stores before error.\"));_.addReactChangeListener(this.handleStoreChange)})}detach(){let{stores:e}=this;e.forEach(e=>e.removeReactChangeListener(this.handleStoreChange))}constructor(e,_){this.handleStoreChange=()=>{let e=o.default.getChangeSentinel();this.storeVersionHandled!==e&&(this.changeCallback(),this.storeVersionHandled=e)},this.stores=e,this.changeCallback=_}}",
        "useStateFromStores": "function a(e,_,E){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:r,{current:a}=(0,t.useRef)({stores:e,areStatesEqual:i,getStateFromStores:_,prevDeps:void 0,state:void 0}),I=a.state;if(null==E||!(0,o.areArraysShallowEqual)(E,a.prevDeps)){let e=_();(null==I||!i(I,e))&&(I=e)}(0,t.useLayoutEffect)(()=>{a.getStateFromStores=_,a.prevDeps=E,a.state=I});let[,s]=(0,t.useState)(null);return(0,t.useLayoutEffect)(()=>{let _=()=>{let e=a.getStateFromStores();!i(a.state,e)&&(a.state=e,s({}))};_();let E=new n.default(e,_);return E.attach(\"useStateFromStores\"),()=>E.detach()},[]),I}",
        "useStateFromStoresObject": "function I(e,_,E){return a(e,_,E,o.default)}",
        "useStateFromStoresArray": "function s(e,_,E){return a(e,_,E,o.areArraysShallowEqual)}",
        "statesWillNeverBeEqual": "function i(e,_){return!1}",
        "default": {
            "Emitter": {
                "changedStores": {
                    "toJSON": "function(){return Array.from(this)}",
                    "has": "function has() { [native code] }",
                    "add": "function add() { [native code] }",
                    "delete": "function delete() { [native code] }",
                    "clear": "function clear() { [native code] }",
                    "entries": "function entries() { [native code] }",
                    "forEach": "function forEach() { [native code] }",
                    "size": 0,
                    "values": "function values() { [native code] }",
                    "keys": "function values() { [native code] }",
                    "union": "function union() { [native code] }",
                    "intersection": "function intersection() { [native code] }",
                    "difference": "function difference() { [native code] }",
                    "symmetricDifference": "function symmetricDifference() { [native code] }",
                    "isSubsetOf": "function isSubsetOf() { [native code] }",
                    "isSupersetOf": "function isSupersetOf() { [native code] }",
                    "isDisjointFrom": "function isDisjointFrom() { [native code] }"
                },
                "reactChangedStores": {
                    "toJSON": "function(){return Array.from(this)}",
                    "has": "function has() { [native code] }",
                    "add": "function add() { [native code] }",
                    "delete": "function delete() { [native code] }",
                    "clear": "function clear() { [native code] }",
                    "entries": "function entries() { [native code] }",
                    "forEach": "function forEach() { [native code] }",
                    "size": 0,
                    "values": "function values() { [native code] }",
                    "keys": "function values() { [native code] }",
                    "union": "function union() { [native code] }",
                    "intersection": "function intersection() { [native code] }",
                    "difference": "function difference() { [native code] }",
                    "symmetricDifference": "function symmetricDifference() { [native code] }",
                    "isSubsetOf": "function isSubsetOf() { [native code] }",
                    "isSupersetOf": "function isSupersetOf() { [native code] }",
                    "isDisjointFrom": "function isDisjointFrom() { [native code] }"
                },
                "changeSentinel": 19,
                "isBatchEmitting": false,
                "isDispatching": false,
                "isPaused": false,
                "pauseTimer": null,
                "destroy": "destroy(){this.changedStores.clear(),this.reactChangedStores.clear(),r=e=>e()}",
                "injectBatchEmitChanges": "injectBatchEmitChanges(e){r=e}",
                "pause": "pause(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;this.isPaused=!0,null!==this.pauseTimer&&clearTimeout(this.pauseTimer),null!==e&&(this.pauseTimer=setTimeout(()=>{this.pauseTimer=null,this.resume()},e))}",
                "resume": "resume(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];clearTimeout(this.pauseTimer),this.pauseTimer=null,this.isPaused&&(this.isPaused=!1,e&&this.changedStores.size>0&&setImmediate(()=>this.emit()))}",
                "batched": "batched(e){if(this.isPaused)return e();try{return this.isPaused=!0,e()}finally{this.resume(!1),this.emit()}}",
                "emit": "emit(){!this.isBatchEmitting&&!this.isPaused&&r(()=>{try{this.isBatchEmitting=!0,this.changeSentinel++;let e=0;for(;this.changedStores.size>0;){if(++e>100)throw n.error(\"LastFewActions\",o.serialize()),Error(\"change emit loop detected, aborting\");this.emitNonReactOnce()}for(;this.reactChangedStores.size>0;){if(++e>100)throw n.error(\"LastFewActions\",o.serialize()),Error(\"react change emit loop detected, aborting\");this.emitReactOnce()}}finally{this.isBatchEmitting=!1}})}",
                "getChangeSentinel": "getChangeSentinel(){return this.changeSentinel}",
                "getIsPaused": "getIsPaused(){return this.isPaused}",
                "markChanged": "markChanged(e){e._changeCallbacks.hasAny()&&this.changedStores.add(e),e._reactChangeCallbacks.hasAny()&&this.reactChangedStores.add(e),!this.isBatchEmitting&&!this.isDispatching&&!this.isPaused&&this.emit()}",
                "emitNonReactOnce": "emitNonReactOnce(){let e=Date.now(),_=this.changedStores;this.changedStores=new Set,_.forEach(e=>{e._changeCallbacks.invokeAll(),this.changedStores.delete(e)});let E=Date.now();E-e>100&&n.verbose(\"Slow batch emitChanges took \".concat(E-e,\"ms recentActions:\"),o.serialize())}",
                "emitReactOnce": "emitReactOnce(){let e=Date.now(),_=this.reactChangedStores;this.reactChangedStores=new Set,_.forEach(e=>{e._reactChangeCallbacks.invokeAll(),this.reactChangedStores.delete(e)});let E=Date.now();E-e>100&&n.verbose(\"Slow batch emitReactChanges took \".concat(E-e,\"ms recentActions:\"),o.serialize())}"
            },
            "Store": "class{static initialize(){S=!0,T.forEach(e=>e.initializeIfNeeded()),null!=t&&t()}static destroy(){T.length=0,s.default.destroy()}static getAll(){return T}registerActionHandlers(e,_){this._dispatcher.register(this.getName(),e,e=>{(this._changeCallbacks.hasAny()||this._reactChangeCallbacks.hasAny())&&(s.default.markChanged(this),s.default.getIsPaused()&&null!=this._mustEmitChanges&&this._mustEmitChanges(e)&&s.default.resume(!1))},_,this._dispatchToken)}getName(){var e;return null!==(e=this.constructor.displayName)&&void 0!==e?e:this.constructor.name}initializeIfNeeded(){if(!this._isInitialized){let e=Date.now();this.initialize(),this._isInitialized=!0;let _=Date.now()-e;_>5&&a.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",_)}}initialize(){}syncWith(e,_,E){var t,o;let n;this.waitFor(...e);let r=0,i=()=>{r!==s.default.getChangeSentinel()&&(r=s.default.getChangeSentinel(),!1!==_()&&this.emitChange())};t=null!=E?E:0,o=i,n=null,i=0===t?function(){clearImmediate(n),n=setImmediate(o)}:function(){null==n&&(n=setTimeout(()=>{try{o()}finally{n=null}},t))},e.forEach(e=>e.addChangeListener(i))}waitFor(){for(var e=arguments.length,_=Array(e),E=0;E<e;E++)_[E]=arguments[E];let t=_.map((e,_)=>(i(null!=e,\"Store.waitFor(...) called with null Store at index \".concat(_,\" for store \").concat(this.getName())),null!=e._dispatcher)?(i(e._dispatcher===this._dispatcher,\"Stores belong to two separate dispatchers.\"),e.getDispatchToken()):null);this._dispatcher.addDependencies(this.getDispatchToken(),t.filter(e=>null!=e))}emitChange(){s.default.markChanged(this)}getDispatchToken(){return this._dispatchToken}mustEmitChanges(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>!0;this._mustEmitChanges=e}constructor(e,_,E){this._changeCallbacks=new I.default,this._reactChangeCallbacks=new I.default,this._isInitialized=!1,this.addChangeListener=this._changeCallbacks.add,this.addConditionalChangeListener=this._changeCallbacks.addConditional,this.removeChangeListener=this._changeCallbacks.remove,this.addReactChangeListener=this._reactChangeCallbacks.add,this.removeReactChangeListener=this._reactChangeCallbacks.remove,this._dispatcher=e,this._dispatchToken=this._dispatcher.createToken(),this.registerActionHandlers(null!=_?_:{},E),T.push(this),S&&this.initializeIfNeeded()}}",
            "PersistedStore": "class e extends I.default{getClass(){return this.constructor}static clearAll(_){return T=_,null==e._clearAllPromise&&(e._clearAllPromise=new Promise(E=>{requestIdleCallback(()=>{e.clearPersistQueue(_),e.allPersistKeys.forEach(E=>{e.shouldClear(_,E)&&a.default.remove(E)}),I.default.getAll().forEach(E=>{E instanceof e&&e.shouldClear(_,E.getClass().persistKey)&&(E._isInitialized=!1,E.initializeIfNeeded())}),e._clearAllPromise=null,E()},{timeout:500})})),e._clearAllPromise}static shouldClear(_,E){var t;return(null===(t=_.omit)||void 0===t?!void 0:!t.includes(E))&&(\"all\"===_.type||\"user-data-only\"===_.type&&!e.userAgnosticPersistKeys.has(E))}static clearPersistQueue(_){e._writeResolvers.forEach((E,t)=>{let[o,n]=E;e.shouldClear(_,t)&&(e._writePromises.delete(t),e._writeResolvers.delete(t),cancelIdleCallback(n),o(!1))}),e._writePromises.clear(),e._writeResolvers.clear()}static getAllStates(){return Promise.all(Array.from(e._writePromises.values())).then(()=>{let _={};return e.allPersistKeys.forEach(e=>{var E;_[e]=(null!==(E=a.default.get(e))&&void 0!==E?E:s)._state}),_})}static initializeAll(_){I.default.getAll().forEach(E=>{if(E instanceof e){let e=E.getClass().persistKey;_.hasOwnProperty(e)&&E.initializeFromState(_[e])}})}initializeFromState(_){this.initialize(_)&&this.asyncPersist(),this._isInitialized?this.emitChange():(e.allPersistKeys.add(this.getClass().persistKey),this._isInitialized=!0)}static destroy(){T=null,I.default.destroy(),e.clearPersistQueue({type:\"all\"}),e.allPersistKeys.clear(),e.userAgnosticPersistKeys.clear()}initializeIfNeeded(){if(!this._isInitialized){let _=Date.now();e.allPersistKeys.add(this.getClass().persistKey);let{state:E,requiresPersist:t}=e.migrateAndReadStoreState(this.getClass().persistKey,this.getClass().migrations);this.initialize(E)&&this.asyncPersist(),t&&this.asyncPersist(),this._isInitialized=!0;let o=Date.now()-_;o>5&&i.default.mark(\"\\uD83E\\uDDA5\",this.getName()+\".initialize()\",o)}}static migrateAndReadStoreState(_,E){if(null!=T&&e.shouldClear(T,_))return a.default.remove(_),{state:void 0,requiresPersist:!1};let t=null!=e._clearAllPromise?null:a.default.get(_),{_state:o,_version:n,...r}=null!=t?t:s,i=null==E?0:E.length;if(0!==i&&n!==i&&null!=E){let e=null!=n?n:0,_=o;for(null==n&&(_=r);e<i;){let t=E[e];_=t(_),e++}return{state:_,requiresPersist:!0}}if(Object.values(r).length>0)return{state:r,requiresPersist:!0};return{state:o,requiresPersist:!1}}asyncPersist(){let{persistKey:_,disableWrite:E,throttleDelay:t}=this.getClass();if(e.disableWrites||E)return Promise.resolve(!1);let o=e._writePromises.get(_);return null!=o?o:(o=new Promise(E=>{let o=t>0?()=>this.throttledCallback(E):()=>this.callback(E);e._writeResolvers.set(_,[E,requestIdleCallback(o,{timeout:500})])}),e._writePromises.set(_,o),o)}persist(){let{persistKey:e}=this.getClass(),_=this.getState(),E=this._version;a.default.set(e,{_state:_,_version:E})}clear(){let{persistKey:e}=this.getClass();a.default.remove(e)}constructor(_,E){if(super(_,E),this._version=null==this.getClass().migrations?0:this.getClass().migrations.length,this.callback=_=>{let{persistKey:E}=this.getClass();this.persist(),e._writePromises.delete(E),e._writeResolvers.delete(E),_()},this.throttledCallback=r.throttle(e=>this.callback(e),this.getClass().throttleDelay,{leading:!1}),\"string\"!=typeof this.getClass().persistKey)throw Error(\"\".concat(this.getClass().name,\" initialized without a `persistKey`. Add one so we know where to save your stuff!\"));if(\"function\"!=typeof this.initialize)throw Error(\"\".concat(this.getClass().name,\" initialized without an `initialize` method. Add one that accepts the initial cached state.\"));if(\"function\"!=typeof this.getState)throw Error(\"\".concat(this.getClass().name,\" initialized without a `getState` method. Add one that returns the full state of the store for persistance to work.\"));this.addChangeListener(()=>this.asyncPersist())}}",
            "DeviceSettingsStore": "class N extends S{}",
            "OfflineCacheStore": "class O extends S{}",
            "connectStores": "function(e,_,E){return null!=E&&E.forwardRef?function(e,_){return E=>{let i=\"FluxContainer(\".concat(a(E),\")\");class s extends o.Component{componentDidMount(){this.listener.attach(i)}componentWillUnmount(){this.listener.detach(),this.memoizedGetStateFromStores.clear()}render(){let{forwardedConnectStoresRef:e,childProps:_}=this.props,o=this.memoizedGetStateFromStores(_);return(0,t.jsx)(E,{ref:e,..._,...o})}constructor(...E){super(...E),this.memoizedGetStateFromStores=I(_),this.listener=new r.default(e,()=>{let e=this.memoizedGetStateFromStores.getCachedResult(this.props.childProps);if(!(null!=e&&(this.memoizedGetStateFromStores.clear(),(0,n.default)(this.memoizedGetStateFromStores(this.props.childProps),e))))this.forceUpdate()})}}s.displayName=i;let T=o.forwardRef((e,_)=>(0,t.jsx)(s,{childProps:e,forwardedConnectStoresRef:_}));return T.displayName=\"ForwardRef(\".concat(i,\")\"),T}}(e,_):function(e,_){return E=>{let i=\"FluxContainer(\".concat(a(E),\")\");class s extends o.Component{componentDidMount(){this.listener.attach(i)}componentWillUnmount(){this.listener.detach(),this.memoizedGetStateFromStores.clear()}render(){let e=this.memoizedGetStateFromStores(this.props);return(0,t.jsx)(E,{...this.props,...e})}constructor(...E){super(...E),this.memoizedGetStateFromStores=I(_),this.listener=new r.default(e,()=>{let e=this.memoizedGetStateFromStores.getCachedResult(this.props);if(!(null!=e&&(this.memoizedGetStateFromStores.clear(),(0,n.default)(this.memoizedGetStateFromStores(this.props),e))))this.forceUpdate()})}}return s.displayName=i,s}}(e,_)}",
            "initialize": "initialize(){n.default.initialize()}",
            "initialized": {
                "then": "function then() { [native code] }",
                "catch": "function catch() { [native code] }",
                "finally": "function finally() { [native code] }"
            },
            "destroy": "destroy(){o.default.destroy()}"
        }
    }
}