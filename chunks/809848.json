{
    "exports": {
        "default": "class A{constructor(e){this.getCurrentUser=()=>null,this.onConnect=()=>{},this.onDisconnect=()=>{},this.events={},this.commands={},this.sockets=new Set,this.subscriptions=[],this.getJoi=e}registerTransport(e){e.on(\"connect\",e=>this.handleConnect(e)),e.on(\"request\",(e,t)=>this.handleRequest(e,t)),e.on(\"disconnect\",(e,t)=>this.handleDisconnect(e,t))}handleConnect(e){this.sockets.add(e),this.onConnect(e);let t={v:e.version,config:{cdn_host:window.GLOBAL_ENV.CDN_HOST,api_endpoint:window.GLOBAL_ENV.API_ENDPOINT,environment:\"production\"}};if(e.transport===T.TransportTypes.IPC){let n=this.getCurrentUser();if(null==n){e.close(c.RPCCloseCodes.CLOSE_NORMAL,\"User logged out\");return}t.user=(0,u.default)(n)}this.dispatch(e,null,c.RPCCommands.DISPATCH,c.RPCEvents.READY,t)}handleDisconnect(e,t){this.removeSubscriptions(e),this.sockets.delete(e),this.onDisconnect(e,t)}handleRequest(e,t){new Promise(n=>{if(null==t.nonce||\"\"===t.nonce)throw new l.default({errorCode:c.RPCErrors.INVALID_PAYLOAD},\"Payload requires a nonce\");let i=t.cmd,r=this.commands[i];if(null==r)throw new l.default({errorCode:c.RPCErrors.INVALID_COMMAND},`Invalid command: ${t.cmd}`);if(!(0,I.default)(e.authorization.scopes,r.scope))throw new l.default({errorCode:c.RPCErrors.INVALID_PERMISSIONS},\"Not authenticated or invalid scope\");E.ExperimentRPCServerAnalyticsKillswitch.getCurrentConfig({location:\"RPCServer\"}).enabled&&s.default.track(c.AnalyticEvents.RPC_COMMAND_SENT,{command:i,scope:\"object\"==typeof r.scope?JSON.stringify(r.scope):r.scope,application_id:e.application.id}),n(r)}).then(e=>new Promise(async(n,i)=>{if(null!=e.validation){let o=await this.getJoi();r()(null!=e.validation,\"command.validation must not be null\"),o.validate(t.args,e.validation(o),{convert:!1},t=>{if(null!=t){i(new l.default({errorCode:c.RPCErrors.INVALID_PAYLOAD},t.message));return}n(e)})}else n(e)})).then(n=>n.handler({socket:e,server:this,cmd:t.cmd,evt:t.evt,nonce:t.nonce,args:t.args??{},isSocketConnected:()=>this.sockets.has(e)})).then(n=>this.dispatch(e,t.nonce,t.cmd,null,n)).catch(n=>{let{code:i,message:r}=n;return this.error(e,t.nonce,t.cmd,i,r)})}setCommandHandler(e,t){this.commands[e]=t}setEventHandler(e,t){this.events[e]=t}dispatch(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c.RPCCommands.DISPATCH,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;e.send({cmd:n,data:r,evt:i,nonce:t})}error(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c.RPCCommands.DISPATCH,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c.RPCErrors.UNKNOWN_ERROR,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:\"Unknown Error\";s.default.track(c.AnalyticEvents.RPC_SERVER_ERROR_CAUGHT,{command:n,code:i,message:r}),this.dispatch(e,t,n,c.RPCEvents.ERROR,{code:i,message:r})}isSubscribed(e,t){return void 0!==this.subscriptions.find(n=>n.socket.application.id===e&&n.evt===t)}getSubscription(e,t,n){return this.subscriptions.find(i=>i.socket===e&&i.evt===t&&a().isEqual(i.args,n))}addSubscription(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=this.dispatch.bind(this,e,null,c.RPCCommands.DISPATCH,t);null==this.getSubscription(e,t,n)&&this.subscriptions.push({update:i,dispatch:r,prevState:i?i({prevState:null,dispatch:r}):null,socket:e,evt:t,args:n})}removeSubscription(e,t,n){a().remove(this.subscriptions,i=>i.socket===e&&i.evt===t&&a().isEqual(i.args,n))}removeSubscriptions(e){a().remove(this.subscriptions,t=>t.socket===e)}dispatchToSubscriptions(e,t,n,i){var r;if(!(null!=i&&\"\"!==i&&(r=i,S.includes(r)||(S.unshift(r),S.splice(50),0))))this.subscriptions.forEach(i=>{var r,o;if(i.evt===e){if((\"function\"!=typeof t||t(i))&&(\"object\"!=typeof t||(r=t,o=i.args??{},a().isEqual(r,a().pick(o,Object.keys(r))))))this.dispatch(i.socket,null,c.RPCCommands.DISPATCH,i.evt,n)}})}updateSubscriptions(){this.subscriptions.forEach(e=>{e.update&&(e.prevState=e.update(e))})}storeWait(e,t,n){let i=t();if(i||0===n)return Promise.resolve(i);let r=a().uniqueId(),o=()=>this.removeSubscription(e,d,{uniqueId:r});return new Promise((i,a)=>{let s=setTimeout(()=>{o(),a(Error(\"timeout\"))},n*_.default.Millis.SECOND);this.addSubscription(e,d,{uniqueId:r},()=>{let e=t();e&&(clearTimeout(s),i(e))})}).then(e=>(o(),e))}}"
    }
}