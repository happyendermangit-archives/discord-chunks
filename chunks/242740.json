{
    "exports": {
        "default": {
            "handleVoiceConnect": "async handleVoiceConnect(e){let{channel:t,connected:I,needSubscriptionToAccess:A,locked:T=!1,routeDirectlyToChannel:C=!1,bypassChangeModal:v,bypassGuildIdCheck:S=!1}=e;t.isThread()&&(await s.default.unarchiveThreadIfNecessary(t.id),!d.default.hasJoined(t.id)&&await s.default.joinThread(t,\"Join Voice\"));let N=u.default.getRemoteSessionId(),y=f.default.getVoiceStateForSession(o.default.getId(),N),h=(null==y?void 0:y.channelId)===t.id,p=h||c.default.getChannelId()===f.default.getCurrentClientVoiceChannelId(t.guild_id);return!v&&!T&&(0,_.shouldShowVoiceChannelChangeConfirmation)(t)?new Promise(e=>{(0,l.openModalLazy)(async()=>{let{default:l}=await i.el(\"371895\").then(i.bind(i,\"371895\"));return i=>(0,n.jsx)(l,{channel:t,onConfirm:()=>e(this.handleVoiceConnect({channel:t,connected:I,needSubscriptionToAccess:A,routeDirectlyToChannel:C,locked:T,bypassChangeModal:!0})),...i})})}):(!T&&!I&&a.default.selectVoiceChannel(t.id),!__OVERLAY__&&(I||p||A||C)&&!function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=e.getGuildId();if(null==i&&!t)throw Error(\"VoiceChannel, transitionTo: Channel does not have a guildId\");(0,r.transitionTo)(E.Routes.CHANNEL(i,e.id))}(t,S),!0)}"
        }
    }
}