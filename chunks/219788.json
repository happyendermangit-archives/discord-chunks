{
    "exports": {
        "default": {
            "actions": {
                "CHANNEL_DELETE": "(e,t)=>this.handleChannelDelete(e,t)",
                "GUILD_DELETE": "(e,t)=>this.handleGuildDelete(e,t)",
                "LOAD_MESSAGES_SUCCESS": "(e,t)=>this.handleLoadMessagesSuccess(e,t)",
                "MESSAGE_CREATE": "(e,t)=>this.handleMessageCreate(e,t)",
                "MESSAGE_DELETE_BULK": "(e,t)=>this.handleMessageDeleteBulk(e,t)",
                "MESSAGE_DELETE": "(e,t)=>this.handleMessageDelete(e,t)",
                "MESSAGE_PREVIEWS_LOADED": "(e,t)=>this.handleMessagePreviewsLoaded(e,t)",
                "MESSAGE_UPDATE": "(e,t)=>this.handleMessageUpdate(e,t)"
            },
            "startupLoad": "async startupLoad(e,t,n,a){let l=r.default.messages(e),s=await l.getLatest(t,n,a);return new f(s)}",
            "load": "async load(e,t,n){let a=i.default.getBasicChannel(t);if(null==t||null==a||!(0,o.isReadableChannel)(a))return new f([]);{let l=r.default.messages(e),s=await l.getLatest(a.guild_id,t,n);return new f(s)}}",
            "handleMessageCreate": "handleMessageCreate(e,t){!e.optimistic&&!e.isPushNotification&&null==e.sendMessageOptions&&(0,o.isReadableChannelId)(e.channelId)&&this.upsertOne(e.guildId,e.channelId,e.message,t)}",
            "handleMessageUpdate": "handleMessageUpdate(e,t){if(null!=e.message.id&&null!=e.message.channel_id)(0,o.isReadableChannelId)(e.message.channel_id)&&(function(e){return null!=e.author&&null!=e.content&&null!=e.mentions&&null!=e.timestamp}(e.message)?this.upsertOne(e.guildId,e.message.channel_id,e.message,t):this.updateOne(e.guildId,e.message.channel_id,e.message,t))}",
            "handleMessagePreviewsLoaded": "handleMessagePreviewsLoaded(e,t){for(let n of e.messages)(0,o.isReadableChannelId)(n.channel_id)&&this.insertStale(e.guildId,n.channel_id,n,t)}",
            "handleLoadMessagesSuccess": "handleLoadMessagesSuccess(e,t){let n=i.default.getBasicChannel(e.channelId);null!=n&&(0,o.isReadableChannelId)(e.channelId)&&this.upsertMany(n.guild_id,e.channelId,e.messages,t)}",
            "handleMessageDelete": "handleMessageDelete(e,t){null!=e.id&&this.deleteOne(e.guildId,e.channelId,e.id,t)}",
            "handleMessageDeleteBulk": "handleMessageDeleteBulk(e,t){for(let n of e.ids)this.deleteOne(e.guildId,e.channelId,n,t)}",
            "handleChannelDelete": "handleChannelDelete(e,t){this.deleteChannel(e.channel.guild_id,e.channel.id,t)}",
            "handleGuildDelete": "handleGuildDelete(e,t){!e.guild.unavailable&&this.deleteGuild(e.guild.id,t)}",
            "resetInMemoryState": "resetInMemoryState(){}",
            "insertStale": "insertStale(e,t,n,l){let i=r.default.messagesTransaction(l),u=s.default.lastTimeConnectedChanged();i.put(e,t,d.KvMessage.fromMessage(e,t,n,u),a.ConflictOptions.Skip)}",
            "upsertOne": "upsertOne(e,t,n,l){let i=r.default.messagesTransaction(l),o=s.default.lastTimeConnectedChanged();i.put(e,t,d.KvMessage.fromMessage(e,t,n,o),a.ConflictOptions.Replace),i.trimChannel(e,t,u.default.saveLimit(t))}",
            "upsertMany": "upsertMany(e,t,n,a){let l=r.default.messagesTransaction(a),i=s.default.lastTimeConnectedChanged();for(let a of n)l.put(e,t,d.KvMessage.fromMessage(e,t,a,i));l.trimChannel(e,t,u.default.saveLimit(t))}",
            "updateOne": "async updateOne(e,t,n,a){if(null==n.id){E.warn(\"updateOne: message.id is null; cannot update a message if we do not know its id.\");return}let l=r.default.messages(a.database),i=await l.get(e,t,n.id),u=s.default.lastTimeConnectedChanged();null!=i&&l.put(e,t,d.KvMessage.fromMessage(e,t,{...i.message,...n},u))}",
            "deleteOne": "deleteOne(e,t,n,a){r.default.messagesTransaction(a).deleteMessage(e,t,n)}",
            "deleteChannel": "deleteChannel(e,t,n){r.default.messagesTransaction(n).deleteChannel(e,t)}",
            "deleteGuild": "deleteGuild(e,t){r.default.messagesTransaction(t).deleteGuild(e)}"
        }
    }
}