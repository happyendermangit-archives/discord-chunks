{
    "exports": {
        "default": "class Y extends b.default{get connectionState(){return this.connectionState_}set connectionState(e){k.verbose(`Setting connection state to ${e}`),this.connectionState_=e}constructor(){super(),this.dispatchExceptionBackoff=new a.default(1e3,B),this.dispatchSuccessTimer=0,this.didForceClearGuildHashes=!1,this.identifyUncompressedByteSize=0,this.identifyCompressedByteSize=0,this.analytics={},this.identifyCount=0,this.resumeUrl=null,this.iosGoingAwayEventCount=0,this.send=(e,t,n)=>{v.default.isLoggingGatewayEvents&&k.verboseDangerously(\"~>\",e,t);let s=w.pack({op:e,d:t});if(!n||this.isSessionEstablished())try{null!=this.webSocket?this.webSocket.send(s):k.warn(`Attempted to send without a websocket that exists. Opcode: ${e}`)}catch(e){}else k.warn(`Attempted to send while not being in a connected state opcode: ${e}`)},this.dispatcher=new P.default(this),this.gatewayBackoff=new a.default(1e3,6e4),this.connectionState_=A.default.CLOSED,this.webSocket=null,this.seq=0,this.sessionId=null,this.token=null,this.initialHeartbeatTimeout=null,this.expeditedHeartbeatTimeout=null,this.lastHeartbeatAckTime=null,this.helloTimeout=null,this.heartbeatInterval=null,this.heartbeater=null,this.heartbeatAck=!0,this.connectionStartTime=0,this.identifyStartTime=0,this.nextReconnectIsImmediate=!1,this.compressionHandler=new D.default(w),this.hasConnectedOnce=!1,this.isFastConnect=!1,this.identifyCount=0,this.iosGoingAwayEventCount=0}addAnalytics(e){this.analytics={...this.analytics,...e}}setResumeUrl(e){null!=e&&e.endsWith(\"/\")&&(e=e.substring(0,e.length-1)),null!==e&&k.verbose(`Updating resume url to ${e}`),this.resumeUrl=e}_connect(){var e,t;let n;if(!this.willReconnect()){k.verbose(\"Skipping _connect because willReconnect is false\");return}if(M.getIsPaused()){k.info(\"Skipping _connect because socket is paused\");return}this.connectionState=A.default.CONNECTING,this.nextReconnectIsImmediate=!1;let s=this.compressionHandler.getAlgorithm(),i=w.getName(),r=this._getGatewayUrl(),a=window.GLOBAL_ENV.API_VERSION;o.default.mark(\"\\uD83C\\uDF10\",\"Socket._connect\"),k.info(`[CONNECT] ${r}, encoding: ${i}, version: ${a}, compression: ${s??\"none\"}`),null!==this.webSocket&&(k.error(\"_connect called with already existing websocket\"),this._cleanup(e=>e.close(4e3))),this.connectionStartTime=Date.now(),this.helloTimeout=setTimeout(()=>{let e=Date.now()-this.connectionStartTime;this._handleClose(!1,0,`The connection timed out after ${e} ms - did not receive OP_HELLO in time.`),this.setResumeUrl(null)},G);let u=new URL(r);u.searchParams.append(\"encoding\",i),u.searchParams.append(\"v\",a.toString()),null!=s&&u.searchParams.append(\"compress\",s);!function(e){let t,{gatewayURL:n,newCallback:s,onOpen:i,onMessage:r,onError:a,onClose:o}=e,u=window._ws,d=!1,l=!1,f=null,_=null;if(window._ws=null,null!=u){if(t=u.ws,u.state.gateway!==n)k.verbose(`[FAST CONNECT] gatewayURL mismatch: ${u.state.gateway} !== ${n}`),t.close(1e3),t=null;else{let e={...u.state};null!=e.messages&&(e.messages=e.messages.map(e=>null!=e.data&&\"string\"==typeof e.data?{...e,data:e.data.substring(0,100)}:e)),k.log(\"[FAST CONNECT] successfully took over websocket, state:\",{...e,messages:e.messages?.length}),d=u.state.open,l=u.state.identify,f=u.state.messages,_=u.state.clientState}}null==t&&((t=(0,L.default)(n)).binaryType=\"arraybuffer\"),s(t),d&&i(l,_),null!=f&&f.forEach(r),t.onopen=()=>i(l,_),t.onmessage=r,t.onclose=o,t.onerror=a}({gatewayURL:u.toString(),newCallback:e=>{this.webSocket=e,this.compressionHandler.bindWebSocket(e)},onOpen:e=>{o.default.mark(`ðŸŒ`,`GatewaySocket.onOpen ${e}`);let t=Date.now()-this.connectionStartTime;k.info(`[CONNECTED] ${u.toString()} in ${t} ms`),this.isFastConnect=e,e?this._doFastConnectIdentify():this._doResumeOrIdentify()},onMessage:(e=this.compressionHandler,t=(e,t)=>{let n=Date.now(),{op:s,s:i,t:r,d:a}=w.unpack(e);s!==b.Opcode.DISPATCH&&o.default.mark(`ðŸŒ`,`GatewaySocket.onMessage ${s} ${b.Opcode[s]}`);let u=Date.now()-n;switch(\"READY\"===r?p.default.parseReady.set(n,u):\"READY_SUPPLEMENTAL\"===r?p.default.parseReadySupplemental.set(n,u):u>10&&o.default.mark(\"\\uD83C\\uDF10\",\"Parse \"+r,u),null!=i&&(this.seq=i),s){case b.Opcode.HELLO:this._clearHelloTimeout(),this._handleHello(a);break;case b.Opcode.RECONNECT:this._handleReconnect();break;case b.Opcode.INVALID_SESSION:this._handleInvalidSession(a);break;case b.Opcode.HEARTBEAT:this._sendHeartbeat();break;case b.Opcode.HEARTBEAT_ACK:this._handleHeartbeatAck(a);break;case b.Opcode.DISPATCH:this._handleDispatch(a,r,\"READY\"===r?{compressed_byte_size:t,uncompressed_byte_size:H(e),compression_algorithm:this.compressionHandler.getAlgorithm(),packing_algorithm:w.getName(),unpack_duration_ms:u}:null);break;default:k.info(`Unhandled op ${s}`)}},n=0,e.dataReady(e=>{try{return t(e,n)}finally{n=0}}),t=>{let s=t.data;null!=t.raw_length?n+=t.raw_length:n+=H(s),e.feed(s)}),onError:()=>{this.setResumeUrl(null),I.default.flushDNSCache(),this._handleClose(!1,0,\"An error with the websocket occurred\")},onClose:e=>{let{wasClean:t,code:n,reason:s}=e;return this._handleClose(t,n,s)}})}_handleHello(e){let t=this.heartbeatInterval=e.heartbeat_interval,n=Date.now()-this.connectionStartTime;k.verbose(`[HELLO] via ${(0,R.getConnectionPath)(e)}, heartbeat interval: ${t}, took ${n} ms`),this._startHeartbeater()}_handleReconnect(){k.verbose(\"[RECONNECT] gateway requested I reconnect.\"),this._cleanup(e=>e.close(4e3)),this.connectionState=A.default.WILL_RECONNECT,this._connect()}_handleInvalidSession(e){k.info(`[INVALID_SESSION]${e?\" can resume)\":\"\"}`),e?this._doResumeOrIdentify():this._doIdentify()}_handleDispatch(e,t,n){let s=Date.now()-this.connectionStartTime;if(\"READY\"===t){let t=e.session_id;this.sessionId=t;let n=(0,R.getConnectionPath)(e);o.default.setServerTrace(n),k.info(`[READY] took ${s}ms, as ${t}`),k.verbose(`${n}`),this.connectionState=A.default.SESSION_ESTABLISHED,this.gatewayBackoff.succeed(),this.iosGoingAwayEventCount=0,this.setResumeUrl(e.resume_gateway_url)}else\"READY_SUPPLEMENTAL\"===t?(k.info(`[READY_SUPPLEMENTAL] took ${s}ms`),this.connectionState=A.default.SESSION_ESTABLISHED,this.gatewayBackoff.succeed(),this.iosGoingAwayEventCount=0):\"RESUMED\"===t&&(k.verbose((0,R.getConnectionPath)(e)),this.connectionState=A.default.SESSION_ESTABLISHED,this.gatewayBackoff.succeed(),this.iosGoingAwayEventCount=0);this.dispatcher.receiveDispatch(e,t,n)}handleResumeDispatched(){let e=Date.now()-this.connectionStartTime;k.info(`[RESUMED] took ${e}ms, replayed ${this.dispatcher.resumeAnalytics.numEvents} events, new seq: ${this.seq}`)}handleReadyDispatched(){this.didForceClearGuildHashes=!1,this.hasConnectedOnce=!0}_getGatewayUrl(){return null!=this.resumeUrl?this.resumeUrl:x}_handleHeartbeatAck(e){this.lastHeartbeatAckTime=Date.now(),this.heartbeatAck=!0,null!==this.expeditedHeartbeatTimeout&&(clearTimeout(this.expeditedHeartbeatTimeout),this.expeditedHeartbeatTimeout=null,k.verbose(\"Expedited heartbeat succeeded\"))}_handleHeartbeatTimeout(){this._cleanup(e=>e.close(4e3)),this.connectionState=A.default.WILL_RECONNECT;let e=this.gatewayBackoff.fail(()=>this._connect());k.warn(`[ACK TIMEOUT] reconnecting in ${(e/1e3).toFixed(2)} seconds.`)}_handleClose(e,t,n){if(e=e||!1,this._cleanup(),this.emit(\"close\",{code:t,reason:n}),4004===t)return this.connectionState=A.default.CLOSED,k.warn(\"[WS CLOSED] because of authentication failure, marking as closed.\"),this._reset(e,t,n);if(this._tryDetectInvalidIOSToken(t,n,e),this.connectionState=A.default.WILL_RECONNECT,this.nextReconnectIsImmediate)k.info(`[WS CLOSED] (${e.toString()}, ${t}, ${n}) retrying immediately.`),this._connect();else{let s=this.gatewayBackoff.fail(()=>this._connect());k.info(`[WS CLOSED] (${e.toString()}, ${t}, ${n}) retrying in ${(s/1e3).toFixed(2)} seconds.`),this.gatewayBackoff.fails>4&&this._reset(e,t,n)}}_tryDetectInvalidIOSToken(e,t,n){(0,S.isIOS)()&&null!=this.token&&1001===e&&\"Stream end encountered\"===t&&(this.iosGoingAwayEventCount+=1,3===this.iosGoingAwayEventCount&&l.default.get({url:V.Endpoints.ME,headers:{authorization:this.token}}).then(e=>{let{status:t}=e;y.default.track(V.AnalyticEvents.IOS_INVALID_TOKEN_WORKAROUND_TRIGGERED,{api_status_code:t})},e=>{let{status:t}=e;401===t&&(this.connectionState=A.default.CLOSED,k.warn(\"[WS CLOSED] because of manual authentication failure, marking as closed.\"),this._reset(n,4004,\"invalid token manually detected\")),y.default.track(V.AnalyticEvents.IOS_INVALID_TOKEN_WORKAROUND_TRIGGERED,{api_status_code:t})}))}_reset(e,t,n){this.sessionId=null,this.seq=0,k.warn(`[RESET] (${e.toString()}, ${t}, ${n})`),this.emit(\"disconnect\",{wasClean:e,code:t,reason:n})}_startHeartbeater(){let{heartbeatInterval:e}=this;i()(null!=e,\"GatewaySocket: Heartbeat interval should never null here.\"),null!==this.initialHeartbeatTimeout&&clearTimeout(this.initialHeartbeatTimeout),null!==this.heartbeater&&(clearInterval(this.heartbeater),this.heartbeater=null);let t=()=>{this.heartbeatAck?(this.heartbeatAck=!1,this._sendHeartbeat()):null===this.expeditedHeartbeatTimeout&&this._handleHeartbeatTimeout()};this.initialHeartbeatTimeout=setTimeout(()=>{this.initialHeartbeatTimeout=null,this.heartbeatAck=!0,this.heartbeater=setInterval(t,e),t()},Math.floor(Math.random()*e))}_stopHeartbeater(){null!==this.heartbeater&&(clearInterval(this.heartbeater),this.heartbeater=null),null!==this.initialHeartbeatTimeout&&(clearTimeout(this.initialHeartbeatTimeout),this.initialHeartbeatTimeout=null),null!==this.expeditedHeartbeatTimeout&&(clearTimeout(this.expeditedHeartbeatTimeout),this.expeditedHeartbeatTimeout=null)}_clearHelloTimeout(){null!=this.helloTimeout&&(clearTimeout(this.helloTimeout),this.helloTimeout=null)}_cleanup(e){d.default.Emitter.resume(),this._stopHeartbeater(),this._clearHelloTimeout();let t=this.webSocket;this.webSocket=null,null!=t&&(t.onopen=U,t.onmessage=U,t.onerror=U,t.onclose=U,e?.(t)),this.gatewayBackoff.cancel(),this.compressionHandler.close(),this.compressionHandler=new D.default(w)}_doResume(){this.connectionState=A.default.RESUMING,this.dispatcher.resumeAnalytics=(0,R.createResumeAnalytics)(Date.now()-this.connectionStartTime),k.info(`[RESUME] resuming session ${this.sessionId??\"\"}, seq: ${this.seq}`),this.send(b.Opcode.RESUME,{token:this.token,session_id:this.sessionId,seq:this.seq},!1)}async _doIdentify(){this.seq=0,this.sessionId=null;let e=this.handleIdentify();if(null===e){this._handleClose(!0,4004,\"No connection info provided\");return}this.connectionState=A.default.IDENTIFYING;let t=Date.now();this.identifyStartTime=t;let[n,s,i]=await Promise.all([(0,m.isCacheEnabled)()?_.default.getCommittedVersions():{},(0,m.isCacheEnabled)()?g.default.getCommittedVersions():{},!!(0,m.isCacheEnabled)()&&c.default.canUseGuildVersions()]),a=i?{guild_versions:n,highest_last_message_id:s.highest_last_message_id,read_state_version:s.read_state_version,user_guild_settings_version:s.user_guild_settings_version,user_settings_version:s.user_settings_version,private_channels_version:s.private_channels_version,api_code_version:s.api_code_version,initial_guild_id:s.initial_guild_id}:{guild_versions:{}};if(this.connectionState!==A.default.IDENTIFYING||this.identifyStartTime!==t){k.warn(\"Skipping identify because connectionState or identifyStartTime has changed\");return}let{token:o,properties:u={},presence:d}=e;this.token=o,k.verbose(\"[IDENTIFY]\");let l={token:o,capabilities:N.default,properties:u,presence:d,compress:this.compressionHandler.usesLegacyCompression(),client_state:a},f=JSON.stringify(l);this.identifyUncompressedByteSize=f.length,this.identifyCompressedByteSize=r.deflate(f).length,this.identifyCount+=1,this.send(b.Opcode.IDENTIFY,l,!1)}_doFastConnectIdentify(){this.seq=0,this.sessionId=null;let e=this.handleIdentify();if(null===e){this._handleClose(!0,4004,\"No connection info provided\");return}let{token:t}=e;this.token=t,this.connectionState=A.default.IDENTIFYING,this.identifyStartTime=Date.now(),this.identifyCount+=1,k.verbose(\"[IDENTIFY, fast-connect]\"),this._updateLastHeartbeatAckTime()}_doResumeOrIdentify(){let e=Date.now();null!==this.sessionId&&(null==this.lastHeartbeatAckTime||e-this.lastHeartbeatAckTime<=F)?this._doResume():this._doIdentify(),this._updateLastHeartbeatAckTime()}_updateLastHeartbeatAckTime(){this.lastHeartbeatAckTime=Date.now()}_sendHeartbeat(){this.send(b.Opcode.HEARTBEAT,this.seq,!1)}getLogger(){return k}willReconnect(){return this.connectionState===A.default.WILL_RECONNECT}isClosed(){return this.connectionState===A.default.CLOSED}isSessionEstablished(){return this.connectionState===A.default.SESSION_ESTABLISHED||this.connectionState===A.default.RESUMING}isConnected(){return this.connectionState===A.default.IDENTIFYING||this.connectionState===A.default.RESUMING||this.connectionState===A.default.SESSION_ESTABLISHED}connect(){return this.isClosed()?(k.verbose(\".connect() called, new state is WILL_RECONNECT\"),this.connectionState=A.default.WILL_RECONNECT,this._connect(),!0):(k.error(\"Cannot start a new connection, connection state is not closed\"),!1)}resetSocketOnError(e){let{action:t,error:n}=e;k.error(`resetSocketOnError during ${t}: ${n.message}`,n.stack),E.default.increment({name:u.MetricEvents.SOCKET_CRASHED,tags:[`action:${t}`]},!0),!1!==e.sentry&&C.default.captureException(n,{tags:{socketCrashedAction:t}}),y.default.track(V.AnalyticEvents.GATEWAY_SOCKET_RESET,{error_message:n.message,error_stack:n.stack,action:t}),this._cleanup(e=>e.close()),this._reset(!0,1e3,\"Resetting socket due to error.\"),this.dispatcher.clear(),this.connectionState=A.default.WILL_RECONNECT,this.dispatchExceptionBackoff.cancel();let s=e.clearCache||this.dispatchExceptionBackoff._fails>0;0===this.dispatchExceptionBackoff._fails?(k.verbose(\"Triggering fast reconnect\"),this.dispatchExceptionBackoff.fail(()=>{}),setTimeout(()=>this._connect(),0)):this.dispatchExceptionBackoff.fail(()=>this._connect()),s&&(this.didForceClearGuildHashes=!0,f.default.dispatch({type:\"CLEAR_CACHES\",reason:`Socket reset during ${t}`})),clearTimeout(this.dispatchSuccessTimer),this.dispatchSuccessTimer=setTimeout(()=>this.dispatchExceptionBackoff.succeed(),2*B)}resetSocketOnDispatchError(e){let t=null!=e.error.message&&e.error.message.indexOf(\"Guild data was missing from store\")>=0;this.resetSocketOnError({...e,sentry:!t,clearCache:t})}close(){if(this.isClosed()){k.verbose(\"close() called, but socket is already closed.\");return}k.info(`Closing connection, current state is ${this.connectionState}`),this._cleanup(e=>e.close()),this.connectionState=A.default.CLOSED,setImmediate(()=>{this._reset(!0,1e3,\"Disconnect requested by user\")})}networkStateChange(e,t){let n=!(arguments.length>2)||void 0===arguments[2]||arguments[2];this.expeditedHeartbeat(e,t,n,!1)}expeditedHeartbeat(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\",n=!(arguments.length>2)||void 0===arguments[2]||arguments[2],s=!(arguments.length>3)||void 0===arguments[3]||arguments[3];if(!this.isClosed()){if(this.isConnected()){k.verbose(`Performing an expedited heartbeat ${null!=t&&\"\"!==t?\"reason: \"+t:\"\"}`),this.heartbeatAck=!1,this._sendHeartbeat(),null!==this.expeditedHeartbeatTimeout&&clearTimeout(this.expeditedHeartbeatTimeout),this.expeditedHeartbeatTimeout=setTimeout(()=>{this.expeditedHeartbeatTimeout=null,!1===this.heartbeatAck&&this._handleHeartbeatTimeout()},e);return}n?this.resetBackoff(t,s):k.verbose(`Expedited heartbeat requested, but, connection state is ${this.connectionState} and reconnectImmediately was not requested ${null!=t&&\"\"!==t?\"reason: \"+t:\"\"}`)}}resetBackoff(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\",t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];k.verbose(`Connection has reset backoff${null!=e&&\"\"!==e?\" for reason: \"+e:\"\"}`),this.gatewayBackoff.succeed(),this.iosGoingAwayEventCount=0,this.nextReconnectIsImmediate=!0,this.willReconnect()?this._connect():t&&this.connectionState!==A.default.SESSION_ESTABLISHED&&this._handleClose(!0,0,e)}}"
    }
}