{
    "exports": {
        "default": {
            "actions": {
                "CHANNEL_DELETE": "(e,t)=>this.handleChannelDelete(e,t)",
                "GUILD_DELETE": "(e,t)=>this.handleGuildDelete(e,t)",
                "LOAD_MESSAGES_SUCCESS": "(e,t)=>this.handleLoadMessagesSuccess(e,t)",
                "MESSAGE_CREATE": "(e,t)=>this.handleMessageCreate(e,t)",
                "MESSAGE_DELETE_BULK": "(e,t)=>this.handleMessageDeleteBulk(e,t)",
                "MESSAGE_DELETE": "(e,t)=>this.handleMessageDelete(e,t)",
                "MESSAGE_PREVIEWS_LOADED": "(e,t)=>this.handleMessagePreviewsLoaded(e,t)",
                "MESSAGE_UPDATE": "(e,t)=>this.handleMessageUpdate(e,t)"
            },
            "startupLoad": "async startupLoad(e,t,n,a){let l=s.default.messages(e);return new E(await l.getLatest(t,n,a))}",
            "load": "async load(e,t,n){let a=r.default.getBasicChannel(t);if(null==t||null==a||!(0,d.isReadableChannel)(a))return new E([]);{let l=s.default.messages(e);return new E(await l.getLatest(a.guild_id,t,n))}}",
            "handleMessageCreate": "handleMessageCreate(e,t){!e.optimistic&&!e.isPushNotification&&null==e.sendMessageOptions&&(0,d.isReadableChannelId)(e.channelId)&&this.upsertOne(e.guildId,e.channelId,e.message,t)}",
            "handleMessageUpdate": "handleMessageUpdate(e,t){if(null!=e.message.id&&null!=e.message.channel_id)(0,d.isReadableChannelId)(e.message.channel_id)&&(function(e){return null!=e.author&&null!=e.content&&null!=e.mentions&&null!=e.timestamp}(e.message)?this.upsertOne(e.guildId,e.message.channel_id,e.message,t):this.updateOne(e.guildId,e.message.channel_id,e.message,t))}",
            "handleMessagePreviewsLoaded": "handleMessagePreviewsLoaded(e,t){for(let n of e.messages)(0,d.isReadableChannelId)(n.channel_id)&&this.insertStale(e.guildId,n.channel_id,n,t)}",
            "handleLoadMessagesSuccess": "handleLoadMessagesSuccess(e,t){let n=r.default.getBasicChannel(e.channelId);null!=n&&(0,d.isReadableChannelId)(e.channelId)&&this.upsertMany(n.guild_id,e.channelId,e.messages,t)}",
            "handleMessageDelete": "handleMessageDelete(e,t){null!=e.id&&this.deleteOne(e.guildId,e.channelId,e.id,t)}",
            "handleMessageDeleteBulk": "handleMessageDeleteBulk(e,t){for(let n of e.ids)this.deleteOne(e.guildId,e.channelId,n,t)}",
            "handleChannelDelete": "handleChannelDelete(e,t){this.deleteChannel(e.channel.guild_id,e.channel.id,t)}",
            "handleGuildDelete": "handleGuildDelete(e,t){!e.guild.unavailable&&this.deleteGuild(e.guild.id,t)}",
            "resetInMemoryState": "resetInMemoryState(){}",
            "insertStale": "insertStale(e,t,n,l){let r=s.default.messagesTransaction(l),o=i.default.lastTimeConnectedChanged();r.put(e,t,u.KvMessage.fromMessage(e,t,n,o),a.ConflictOptions.Skip)}",
            "upsertOne": "upsertOne(e,t,n,l){let r=s.default.messagesTransaction(l),d=i.default.lastTimeConnectedChanged();r.put(e,t,u.KvMessage.fromMessage(e,t,n,d),a.ConflictOptions.Replace),r.trimChannel(e,t,o.default.saveLimit(t))}",
            "upsertMany": "upsertMany(e,t,n,a){let l=s.default.messagesTransaction(a),r=i.default.lastTimeConnectedChanged();for(let a of n)l.put(e,t,u.KvMessage.fromMessage(e,t,a,r));l.trimChannel(e,t,o.default.saveLimit(t))}",
            "updateOne": "async updateOne(e,t,n,a){if(null==n.id){f.warn(\"updateOne: message.id is null; cannot update a message if we do not know its id.\");return}let l=s.default.messages(a.database),r=await l.get(e,t,n.id),o=i.default.lastTimeConnectedChanged();null!=r&&l.put(e,t,u.KvMessage.fromMessage(e,t,{...r.message,...n},o))}",
            "deleteOne": "deleteOne(e,t,n,a){s.default.messagesTransaction(a).deleteMessage(e,t,n)}",
            "deleteChannel": "deleteChannel(e,t,n){s.default.messagesTransaction(n).deleteChannel(e,t)}",
            "deleteGuild": "deleteGuild(e,t){s.default.messagesTransaction(t).deleteGuild(e)}"
        }
    }
}